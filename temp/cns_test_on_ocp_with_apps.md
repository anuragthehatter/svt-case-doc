# Test CNS On OCP with Apps

The target of the test is to see the performance of CNS under the IO workload
 generated by the application shipped with OCP templates. In this blog, we 
 focus on Jenkins, Redis, JBossAMQ and GitWorkload. The code of the test 
 can be found in [svt repo](https://github.com/openshift/svt/tree/master/storage).
 
## OCP cluster

OCP version: 3.11.0-0.25.0.git.0.a95c194.el7

CNS image version:
* rhgs-gluster-block-prov-rhel7:3.4.0-X
* rhgs-server-rhel7:3.4.0-X
* rhgs-volmanager-rhel7:3.4.0-X

| role    | no.  | type          |
|---------|------|---------------|
| master  | 3    | 4xlarge       |
| infra   | 3    | 10xlarge      |
| compute | 250+ | large/2xlarge |
| cns     | 3    | 4xlarge       |

## Generate IO workload

For each application, we choose or develop a tool for benchmarking and 
repeatedly call the tool to generate the IO workload for the application. 
Sometimes, we containerize the tool if the too itself is a standalone 
application and it requires its own running environment.

For example, we use [YCSB](https://github.com/brianfrankcooper/YCSB/wiki) to test
against Redis server which requires Java/Maven. Then the YCSB container runs in a
separate pod as Redis pod. Those two pods stays in a test project.

A PVC is used in the application pod to store the data generated by the application
via the benchmark tool. We create such test projects as many as possible. All the
PVCs are backed up by CNS, providing PVC type *gluster-file* and *gluster-block*.
In this way of scaling out, we will know how CNS performs to support the
applications under consideration.
 
## Results

### Jenkins

Pod parameters: memory limit: 6G; PVC size: 3G; PVC type: gluster-block.

| instance | total build | failed build |
|----------|-------------|--------------|
| 1        | 30          | 1            |
| 10       | 300         | 60           |
| 50       | 1500        | 304          |
| 100      | 3000        | 589          |
| 200      | 6000        | 1017         |

On each Jenkins instance, we trigger via Jenkins rest api 3 builds concurrently
and repeated do this triggers 10 times. Then we check the status of the builds
and count the total failed builds.

The Jenkins job definitions land on Jenkins instance by [JJB](https://docs.openstack.org/infra/jenkins-job-builder/).
Each of them is Jenkins multi-branch pipeline job which checks out [a springboot
application repo](https://github.com/hongkailiu/gs-spring-boot) and run Maven
tasks `install` and then achieve the built jar file and junit test results.

The failed builds complains about incomplete/empty jar files as Maven dependencies.
We believe that cleaning up the Maven repo folder after each iteration should
increase the successful build rate while we leave this as future work. 

The test is not using gluster-file because of [1588562](https://bugzilla.redhat.com/show_bug.cgi?id=1588562).

### Redis


Pod parameters: memory limit: 6G; PVC size: 3G.

gluster-file: Did not go further because of no space left on CNS.

| instance\throughput | load      | run       |
|---------------------|-----------|-----------|
| 1                   | 13,532.56 | 25,577.91 |
| 10                  | 13,969.80 | 26,771.05 |
| 100                 | 12,113.42 | 24,425.35 |
| 250                 | 10,150.21 | 20,870.68 |


gluster-block: Did not go further because of [1627962](https://bugzilla.redhat.com/show_bug.cgi?id=1627962).

| instance\throughput | load      | run       |                       |
|---------------------|-----------|-----------|-----------------------|
| 1                   | 14,191.68 | 27,644.39 |                       |
| 10                  | 14,134.37 | 27,721.02 | missing 0;2 results   |
| 50                  | 13,182.41 | 26,937.44 | missing 30;16 results |

We use YCSB's [workload_template](https://github.com/brianfrankcooper/YCSB/blob/master/workloads/workload_template)
to load and run the data for 10 iterations. The numbers in the load and the run
columns are average values of `overall throughput (ops/sec)` from the output of
ycsb for all projects on each iteration. 

_missing results_ indicates that exception occurred during the test.

### JBossAMQ

Pod parameters: memory limit: not set in the OCP template; PVC size: 1G; PVC type: gluster-file.

| project | throughput |
|---------|------------|
| 1       | 87,972.24  |
| 10      | 83,035.75  |
| 50      | 20,220.86  |
| 100     | 9,790.12   |
| 250     | 3,799.39   |

[activemq-performance-module](http://activemq.apache.org/activemq-performance-module-users-manual.html)
is chosen for the test. It starts producer and consumer of a topic for 5 minutes
and we run it for 10 times for each project. The throughput is the average of the
`System Total Throughput` output by the benchmark tool for both the consumer and
the producer on each iteration for all projects.

The test is not using gluster-file the AMQ template requires the PVC supports the
access mode `readWriteMany`.

### GitWorkload

Pod parameters: memory limit: not set; PVC size: 3G; PVC type: gluster-block.

| project | time   |
|---------|--------|
| 1       | 23.90  |
| 10      | 23.94  |
| 50      | 46.40  |
| 100     | 60.71  |
| 150     | 117.75 |

GitWorkload is not an application from OCP template but it is somehow a 
 routine workload in [openshift.io](openshift.io). It follows the same 
 testing method as other applications in this blog.
 
We use [this script](https://github.com/openshift/svt/blob/master/storage/git/files/scripts/test-git.sh)
to generate the IO workload. It clones the [Eclipse Che repo](https://github.com/eclipse/che.git)
(currently about 200M ) and then does `tar/untar/rm` on the repo folder. The procedure
is repeated for 10 times. The average time is calculated for each iteration of all projects.

The test is not using gluster-file because of [1589359](https://bugzilla.redhat.com/show_bug.cgi?id=1589359).
 
## Issues and workaround

TODO 
* PVC provisioning and deleting

* block backing-up volumes

* CNS device volume size and `openshift_storage_glusterfs_block_host_vol_size`

